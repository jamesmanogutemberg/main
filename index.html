<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked Page</p>
                <p><p>enter the passsword to unlock the page, don&#39;t try to guess it, you&#39;ll just waste your time.</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Unlock"/>
            </form>
        </div>

    </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js" integrity="sha384-lp4k1VRKPU9eBnPePjnJ9M2RF3i7PC30gXs70+elCVfgwLwx1tv5+ctxdtwxqZa7" crossorigin="anonymous"></script>

<script>
    // do not remove this comment, it is used to detect the version of the script
    // STATICRYPT_VERSION: async

    const cryptoEngine = 
    ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 *
 * Mirrors the API of CryptoJS.enc.Hex
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())

    const codec = 
    ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())

    const decode = codec.init(cryptoEngine).decode;

    // variables to be filled when generating the file
    const encryptedMsg = '4d464fb7a42d2c63613f4b1f170be03be01e2149112cb16ec7c9f74618200e3cd8750173a622de665488226ab9f2cd2a3e1ff3c53063919db2f36bcefb0c251078a9490816fe87ed94b3a888087d3b91ad755f9cc7f60721448a3bd14dc50848ae0a72ac2606b9df5949831503fef802b0e0fe8e45f8a90306bf3f8bfcd8ca83a87fe7d86d6834be7cf2aeb4f6b36d27987b6af0a2cb371de484e9da0e58d2b8728a9b93164afbf91ceb3064266c6f551332b488db999fb0539bafc89534e4d01def1b4e9ec7a72fc58b3b7d928a7f465878f313914647613d3615a8a079d7e760515254909662bb6f2209f5896b6480e5e5cb22f1f85f069bc1c03616eca378db844d0c39c255a0d6a2e64874b22c60b230d358f0156b7c140b789cfab1e25033d9606d92bae6ab404bedec55c290f3a799b6779b8d893a2395ade5a136f0c577e1d815507188d0e913c6f29c387315c79f922bd7f0b59adb64e8a9f143909aedcd4063c485d57dff6cf8aed056d667e2dfc52c70df6c4f1fce6ab4715787f98523bc269d14072687a6abf41320a0b68785bda3ddccb39c948cf3e4d0b9fb62c09e5b929f9ec7c979ffaf12be8da33bb1b971ca4ad713f56d97d7e050b3e888e10efccbaf96e0f0be6e1b0539161448508155160e526099cebe5839040c4c56b0535d7aaf9e8b9b15d8d75f26c1a7e5b99a91a935dc0ae1a7bc6753f0c37b8598be764c0ac7a931365a37b9ae205ee7a69e33153b975575ab1aee639ce86c41bb5d5231477211bc740d3bb3d4752f2ccd6e0865ea076f0296dbeb69e60351afc70735a1e661741b056463eda376136f22efc492cd94493718c3b7a51d0d36c84ce2e54d37e46951ea68c294f3b8ff3e89060cf59860fc0d4f02b42fe46a0aa0870fe094cb53983edc21cb638fdd6e1a6e49d1ef7948d963d7cdfead86135d48d4ccac9c1e08ef0dbdbeb7ee20698b8f771d5467230d0e5789a46f06f5cc4d4110054a0d3cc9c73a98a5870b7a71ee74a591225089f5fbf2c8df7697338fe037b2d45df63a36b23a2453b20f8b67809f0b879a735c6d257e0ac253c3d74055b95fcc0d5ef444117762e0d4233bc91dc78a0d8a18d7324dd40f0f135c35a380efc8f231506afb14671289b0e34894948f1dae6a45121a409857e72ac9ed6e01c6e0f7b0d3cc5b0c6fd1e2bbc93d2e6ee8dad466934e25469f6020f628b5ffe9de7b8f819c8caa591a7c729013be9ae56139cff3e5975cb8ea3f5189b06ce27c325a87d2992cf0730f57e8df0ac3996db109bd5ed7e9618fe3d830d408d9f76fa41e15847f5302dad6568805d28cc8eaf24838d84775d70289af014988c921180e3994ae7489c6755f8772deea125a440ce206c7a2127896ad05d8dd8d005bc1883ba646319bc4b5e3e540d84f9d618a32a1dd917585789a41f944c512c966f12ac938906bde7597db4e5e8645d28f6bae80b75d06281b58e29021c92a2e63b66a962591ae21a4df5ea572dd25bdd9d7be655b2d50a6280fb2a6784dabe20471f93247ad0b3080036dea9c25c211617ea4fec7d5a60998d5c53c7d0f8917fe59891c1087045d2e665d2bc78d313b90437da35c58172177b35d07fd789d4229e4bf7a3d8abc41140b321a6f5467ec37320a74cb98f74a89604abe5ba47142558bdaf919f5ca32575bfdb20b662d0f6804be2f9eeabbfa2f479b03068bc5502658745f328bacc849a78b1e46a622899d6b631598db81109c57646ef001a33cd9f296321916576668bdf0089c3ffe2b08a1d40387da93ebf48dce8a63e9d45b57db2aefe269496da08faa66a6ae715f789197360da255d7a1338d5ec4289dd19e21ff526a9b6f27e7ab365b7fcc32f57b970c885c1a546530e9718c818c6dc6086a2fe49ea82573d815b904869fd4e9d57d7c30be7af7bdb17888537b84d5fa5beaa6260e128036f3399a55f732744f05195ce1dd73183d4699c31c5a84b8c73a30ee7afc01aa3115774b2019d5cfbb23601a41ecfbfed6eb1e3a188d5fa3c31cbf489ef834e4745ef36db8ea2c5bf9688a2992d6e558611c549369bdae6d7cb3ee5bbcc40af750c75dacb329ca15e004270714af14898c3c0fd8046314d001db8b5450a5ab4f2cd28e19606a3bb31bd59309819fe674e1b73621cee3b4b524ec38d9e1116adddcfe01aa55d394f01c3989e097f7fbbef3b1c26af363bfec89314a47374cd3146be56d546bda0dc52a1c11728bef8db109657be90ed113e151035c507fa884378d80aab78ad6da96e3b2aa2b34a092e38cd14d80f9909e3b5d1bdef736d47d56eeb85ea8f8e8f6c01344c352479c0a4e3b2b71559a3f4e359f0bf494d7e07fdc64aa860f832fdb6ecd85ba9ddc4546ce2c42b18c8f1f5c6333417628f0a761a0309bf249882131e7347547f577178674c0c2db1a7668cbb80d99d73a10f91d73770197eb89879f427c6c2388420942399e1bdc9d56490e870bb9920239e70241c3df88a4800329daa0b3d1017365a50fb48fa7905f01765949c641838770b005fedac012a3252cfc9c9f5c2f847726b6831b5a7330471b332a524e8734fd927e700c940520842b65cfde2db3ea792ccad5f0684cc0bd89e77710846d9be3f2b6958d1abf3f63e1286bc2c5bc9d5f35a143a0d1f30b993af85c141306b2ec1bff550c256536829da46e2871c001a40b06ae7c10f226c8aa49095268d785374838485ed0b1e9d7c3aa4068b661b6ff85a9ed28c4a481468d6a0b4376b8c2d74bed0e291292f8c655f4380451b5e86ae07dd44be3d7c20d42090f7c2c41cf9971b20c061c06afad4a3f4ba75bf503512ce3d8562f4f8fdcb822526a88c8ee9c64e693339105140de684447a588c0261f905d0af83ad461c80f08d30a9043df4959bdb628319e85e3e00657e4a0577f002914dfa57638174fa47ecc2361b42a8f0ef76b1309ca487f73f75d4c6d591d82f679cb6da8c9011104e2e86154440b84d1aad978ae0923f817572c58ffcf7900c7bf0a6c30041c2091ba00bd53e13b826676a2a20bf6f6323efc1093e4d19bcc72b446a1ef16a37483136f67dc3e82ca0883807bc4e0ac3600d98f2732b07d98bda536d5aac4e5340bf3a029a4a427a10c8347bc1ea904f61fac773183d34b2ed4fcc502fdd1d7a564470c133bc168c100485ba9344fc5f6a3bcaa43e4bcc22dc0756a826d501ac0c2e4145643730d38d15911b856efea36f1bf7e5ac5434e003c849d9cfa671408a7d96267cc9243491f7511fdc3317a945c66770c87d33b5478628a8a68c42d4879f1c34a704e1bd983826f8275e6d5808302ff372f70f7ccbe7aa38eb6c14beee3f426bdbba9c2f463cf850df06486c592eac63292e7c00303c1a13f4b0d0e1ad67e3c54951740cef5bc19332cf2ed267aac8247dcddb628ead7fd820d393afccc4c19b0bc2e077db8b58986a24a13a54ed5f4d4a45fb2dd0950496be2a1ed14a86d868d0db9e7c5dc7468e606fe24c6400ec7e6a783214a635c4ef798e6b29ccb77d3c3f4f786369eed115b74604db7486997df7058490e2b68cf188640ec6ea821c80184e23bc50c666f9742d9a66568c82ca22e44dbb675ec114ce86549287487b55c1488c2fc45e3491896e07d809a0056b46d52a8ff67890d6b1af43f45afdb7379d49d616498522b5375322c54a65cc30028985fe0ccb44d2d5690ef276a14c0d08b065e67b2daecd15e571e301bca40a486216c17eaa189d23bac512ce9a52cf76a49893ef23ec442d14c1466650cdf7bd5ce9d1a6b0883402ee1a551c2c0f47775792530ac6bfc5a3ade6ff0e24ac564ed4dcc650bd286ef58c258b21033ff8f07dbb4caf9b31fa9c9d60c3613d3e0345901afa5914dce4276dcc6abc5d6b858fa7a64dbdbba0d44e0bb5af50d95695f2465f4121fc7d2c097b20d133f70bccb18265558233e63a05c16d4996f257148b48f01c2d1e35c84984951703bb5ef7bda438445bec1cb4a032c0877d6e003187fd6864c6faf5efcd244874b6d1161a42f6cf3556764167f79b8ecb152cc589d64cfdbee1cfafdea3a12f90fc21ea54cfad0fd0182bd47b66c06110bccecd5473afa16e28093ef2bd50e3c05c51742462f3b00f653813fdc06bfc7f1674d41eff4b4cc16cf058ef45626ed949d26f37a7f3ee48ba699b3c2926fc243d6ffd038fdfb82ae1cda4b8ec228a1b85a6fb0e8a169ec4331a7ed06a18dc2e10cab2752a8358947f77079e8b2af0a03a38dddd73886abee3b8f2c3e6496e66e6bb2a0f8a9dd7b7723692f46bb3bb5ea006229dd0293a25f9283e57c292b3474b98289a9c1208f1cf59963d14787a1116dd42e0e3c87cf40c67f7579ab2862a4411d3180b74830dc94de47a0b5b7489972cb6a716adad4829a2a92a06c2a81b2ccde36bd7d91b118943e110978447fca04f085220a52031aa11dd04e166b474917505f9621898d99944a263f7417b61bd0f7321d6bf86703d88f7a5e2e81d809f4757f4a492c62c980b820ae89c0a6f55fc8527df05461641b18ea2113c59c800134a1a69b7925598762a81fd84072908b0905e235da101098a496f7ef4422538a40d5f04a507f19bcc3761a64bbe3db845c8108183305594551726d51ec97d0ea4ae89a090d9a064403ed7d24153734abaeafd1918d3faaf89fb20bd283b1c1915859c41c73a1f9937b8d290b0bac12592f3bcd4f62b62e2012a1653527571c0768088af67edffc0e707e18397ed7f0d479057b5615f9725615b0ae4d7e65fc8a46c3858d86abc601d707f32506455412fd654a0f338df6451f611469cc860a23a3483f14960b4638333e052e6a6961672f1439f867a098e11e49594f8f940ff7c3c30c63edd2d89ebc225e9058520be877022ee01e658c0577044f80942d0913a172c7eb6fe9754049c72aed2b58110096e425d27cdf6e679c6fe5f5e60c2aeeff3aad91d',
        salt = '2c00badfebfe2e49839c89075af5a1f8',
        labelError = '',
        isRememberEnabled = true,
        rememberDurationInDays = 5; // 0 means forever

    // constants
    const rememberPassphraseKey = 'staticrypt_passphrase',
        rememberExpirationKey = 'staticrypt_expiration';

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param  hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        document.write(plainHTML);
        document.close();
        return true;
    }

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        localStorage.removeItem(rememberPassphraseKey);
        localStorage.removeItem(rememberExpirationKey);
    }

    /**
     * Clear storage if we are logging out
     *
     * @returns  - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        if (!isRememberEnabled) {
            return false;
        }

        // show the remember me checkbox
        document.getElementById('staticrypt-remember-label').classList.remove('hidden');

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        let hasDecrypted = await decryptOnLoadFromUrl();

        if (!hasDecrypted) {
            hasDecrypted = await decryptOnLoadFromRememberMe();
        }

        // if we didn't decrypt anything, show the password prompt. Otherwise the content has already been replaced, no
        // need to do anything
        if (!hasDecrypted) {
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            shouldRememberPassphrase = document.getElementById('staticrypt-remember').checked;

        // decrypt and replace the whole page
        const hashedPassphrase = await cryptoEngine.hashPassphrase(passphrase, salt);
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

        if (isDecryptionSuccessful) {
            // remember the hashedPassphrase and set its expiration if necessary
            if (isRememberEnabled && shouldRememberPassphrase) {
                window.localStorage.setItem(rememberPassphraseKey, hashedPassphrase);

                // set the expiration if the duration isn't 0 (meaning no expiration)
                if (rememberDurationInDays > 0) {
                    window.localStorage.setItem(
                        rememberExpirationKey,
                        (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                    );
                }
            }
        } else {
            alert(labelError);
        }
    });
</script>
</body>
</html>
