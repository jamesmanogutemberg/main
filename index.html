<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked Page</p>
                <p><p>enter the passsword to unlock the page, don&#39;t try to guess it, you&#39;ll just waste your time.</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Unlock"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"faad102c45a9cdf95f7f6b99ca1699e09660aa960b1bce32aae99601f25d64bce33f6c3b32e404ed33980c4977374e59c3e8a0ff3286137f4338ff7e277279db0340ee69cabe1ffd98168ae79722a3f9afa5642c52dd379345805bceeb474bbc2839e1466414384a5f07de17367aae1bc13aafe1452004e59c1613c6a24b1f1cd2a25b553673c996e3e18806da34404e939b240396b98e923bb39d014dfb535f88d8007ce8975cfdd951d034d455773f4c14dafbcc8d7deb28517af7f19ff838e107ff81dd6518e2acf14203d76c09a0fa775e0edec667b52965721c546abaf5d93452bf8cd08c71108aacab159c56632cf1fe698043fcedeaf5bd63c2fa54f89a73b09e6c61bc9cbd35b302ea62ad7ec2b7ced9a501617d24e8ca48165e915981d844eb20dde046417f7dfada0f33e719d2b0e5a179ec849de61f716f9839b0be1c319a585bb8493b655d8fe4bce1d3f2fdf810082e10a5924872d16d6ade9a40d7af27e360ef0a25b0b100db9ddf1b5cfc8f784928184c284bf2ffc9d2a638875899fe81eecd930ac60a9e86b498178794aab6d73655d21f182dce0df26ccd75e57d7d7daf50bb9a0670359741ff3da343bcc66d01de02f60be701ab161df497923524123802c389ca15f415a2d2119b0719a825846a3e9ba8c68b546c938e0602708d93957c5e05f547e3978fc651a4a2fe9a6f78735b2851112f419b5e62024895a1c6ceb19662fb7208e5b9db432b05fc3dc44e23cee0d33e92b80c2c8994459a36b143fbb8fdbc70e3a720fb40a5210c1c94b97cdc3c2fca59b09f5e0c86c0ecda64081b75332147b202fb106febfbd4a14cd06ad0644b322df5eece7f1e89d7cad104b73048dbc4662f100eed674f0be64859d3674dddd49c01f7585e4f60e187bfa593b91d96dbc7233fec414533bf979b6e4427b0696e9258cfe05844f5ce84050c5eba1a3c507c1fbd401ec97d344883ee4073482827d95f40a907c565730f4b77c265f1b551b1a2c24adea35d7e0426ed592f9e35fa7e9bf14dc5544b9ad9532abe186d66cc95ed28415ddc0a596469273e6284a974ca9ad30f54fcb276e1914d16b38f50f06d572b14ad4b4ac8cfdeb56e1d309e2ef776e8bb2cf70748b9b7576fea8e35531708df9a35bce97c26cd1cd325496b40bc35f27055c9ac02166e3855c408f9977ad236e5c4065feb0f25842852994b6fca9382832ec7eee562912976da462ca1e16d905a5b4aa28c7223d5067df769af7e659b13126caacdf6d471a2ec214495a98a0fbd1f4c41e4c47cbe3f87ac25d7532c700771e541c1f7b5b44816db483749ad2fca6ff7727592ac9bf96b6a43ba8a9aad91093979f43c5a0039be917f1f14d35b10c90f70d99ba436f0f0d101af6fe475ec05b8bfd8cb05a363558a0152bf8de6ef3557eec1313e0ba22cc25049fcdc47a5ff9f57d497a5719dc92f8633197172c9561b5dd55f0df93cd025af4becc37ded41ff98415033fcc310be8aff02491818d95884d06a4cbf4f5114c44d3e43197181e47b538ce38176c5252727caeb5c01ae8bb7013b3d158ae80278d0c4560fdb8e985fa040da797f8d29e17145d6adb23d3a47a39a4a4d3680f330b664b7efc620f7f075f9626b0d8f78453a63c8b49d2cfdef4ea40b01e73c32c7b0d2ace588803fa2bf12062ff1bd5dd8a39ebbc733239900d3fc77de15bc6bf0a77e1e2ea5226c0769eb5bd4d8322e3f79dc2e15bbbdc5a5ba0ea60c14cb46dd2d13539c116a5df9017f2e33a9ceb54e90eb4933a7ddf8701db8bd3ef3081f17aa6de7cd90a4bc480204d12e9744a5ccfe3ca49914bf0333965a270d40d92f1fcd6e7019c7699f900b3172a74165e84f001607561ee094c8e198e27989797f520f9964e88dcef4d312e49bce33964d3ec2e6d2cf897cdbe0f4c5dc9d370306c6252095a8c694db062f0c8557f6fdfab9e46922f71d440647c8270acf71fff68086a66d3c99b488dbc4c74506b158a79c4b7d0b2fd445070b3652bedbc959ed91c9b25db145afaf6b7b1379395e6ed447755e58b5e8fa96fcad9dfa2780c1a8c18583fa8740921731061e5ec46de974dddc3372654b8c74e079954553dd1b22349f4b14678697625afa464bc7ef68cb1fc4bcb7c24cd42322fe2717e474a8c885110e838483afbca49c0888301974fb8b1edd0f1d9f23b7d323e0856132fdc5e82fc44b4f55fa8b295adf2cc76d4c99820f32569d8bd5bd2443a83f0797e3b05fbfe032acdd7083f93f70914271ca07de54d043cf3272dfdef2427e0e28de4af4c817c3109b272612f5758a2408e79cf37d4c8441b3c383db901993ed3028578b06baaf0a95f06eae01b625c01d88d3581fd7a8337c4fb04a54d700abf0f8f679a4dcf647a3ba7661648ed0d77477add64fe37ba5a22bb8f1f25827cff487b69304bdb7dca8472b257ec0e013ac91da864ceb404e6743a30077993c96f649e8f6c63426394b14c9f3e4b1f02c02d2d8bae620c00c52d2b9eaac844b5a0233792d127d893bb824114625ef5c6ad19b5dffb291b9147ab2293fe3930caed2d271b7c27e3833e3be1bf0eb6d5338c969989ac3d77ccfd7e3623c01d6ea7e2f75153dafc36539361a2c433bf4a815bb0b2b9eb80bdd1fad5dedb5c374148ce2a1b320e4388c2c83fc86a3769708b73016e443d05fb84b0564ce584064902c331b89c84a355031508d51e77a02d39d2a7f84f473212bd583d196d8886216905210088df35d9db3eea5cde452853ed1408421a8e3a74d788c944555815c71852871af1f8af870eee8516cd2e8da1cb3245ac3a8fa4b110d545aa33011a0c26c14ea5032ab70d83cf0b3ea3ef2984bd2b2a99d5753c28b10e2871ef30604856893e7b298fde953b94c9688cc79fbecc459b4ff71bda750f9ce158470ff7d7cf730873aea3218d97adf1faba0c17b4bcc33f02b5442e12f09468b513643e9e3d1abfc35696f99c11f078e0626bea395fe5e2f6fc72029c4ed6de5a639f80a9a356e38e93bc9a831b5bd315665918a8e69583310150dc7d0975d892759fc20744a18b2152955b1b22a100e9bd0d8052ee60ec58cc1d126732698e750369e435618dfad62cb39f917391924081809e960a455a179489533392a5691de92e4c48989ca9db6453a1f47f53757536071753defdd40fc60ba93acbd1c5b23d609a72999edd30bee0d96352fc53a184e6408c10045931f87c7c422fa3cfa9bad52bbe1ef65b786ff8b8f0b9a41ea3f6257fd7c0b02aa8b344975522940440046998c5b2ac26df22e91561f99717b1abe31cf9eb4ba271d65e9e8b8fa7dbd3dcb2acb46518958c4d0182e208eb2b6d80a00ae18cb944687e17b62bf48c9ec5d9c99984f287390c3987fc0f7eff6401911cbb4ebe69992570ebe10938d61f49b712ff201816ee241dba2b93f7c4cec31f5076e160f0cdd9865a5e047de9fa7d7bd614ed47e2acdb34366a47878d58d205e4f967f079b3fec1f62ec39492dfef06b354edf7751df6c54ddeacdf6b6ad02499b71ef2863927a7c1a49a056a54275b6602116e85529bf7a796e170c942fce68aa749f345a8433e4a69ba77ed9c1fe366995759f60e88e0bf5e00446247ac963775ad05bca64e5d87a384b9677f191755d2a653b50affe6b77170edd397afc53851260f18480daa5ad0f0eddd0ff7985534b1070b7bec536e2bf0a8b06eabdae41425f5178a52388ccea51684a9a6fe88bc8a64a7847f61a71fea5db0495724007ccd359f595e23ae4b5ca544bd069f2f1e5f8faccb2c395f587e302bd68f21675fed72b5d5764eb6e540845c922133fc3677336bbdee13beda7e42eb18f84ad4155440cc8c6a1cfb38ef911516f9c0411c3964ee9b11b8d42858aa628158224c752c728524b5d0e74cd2c8660fc83e5aaababf0e401b31067d40f56276566abdd6f245586ba6fa7241f84c89844f39b1ba87b592c61ffb0535a9df93f34a87c59ff720e8aceb025cfec4dd58be1ac0394cd631cd5ba9c47fd8f3f504954ddb2fa8566086a14af3c22ea571cfa74c57fc27be51859456d65cfe81b52b25b0f028e97c7ae61420bf85169dcc32b777e8c289e1cf2f68f8a626d1940ad46460c51c4388ef71337938d1a6242ca44d444a55ac5289dcfe129c06921dc6a387a8b45982b542ef05f26090a4b03b748a13a39dfd60ebdbb41fc4dfbbf7b49450f97d1fa452ef1593e5e15f8ed417b7804208427ae910c064a233e654fb78c73456b3c4a2818f1211d6d4f378c1357c9eb0b1dca73eeff8ba1c3b614e6585c9c537ffda868697057c60a61bf164bddf792e6e912cd8ee9cc50f97bd0aff441c3675eb4e0b82b10c64add233dc032ab8bdf0874d782df5c5d9f44987eab3075a5f8f92f7d81dc9dfc2f6d5ac1ca28babe1757e43486a1d819ef1dd21ce751fc478d629403c713f8d71f1132eb91d239eae79a681d51c820d7a0467bf106302e51b91f3eda76c5d089952917444023fb9ef08279f14ead7849d50bc79e3179c4209d13205080e7d2b6a8833630b736fdc0c0e5c3929883d641598a424d0bd9255b75a8e54f0c77bda4d02a89918ef660d218d3e9a192dc0cb9ce5b9076cecee05d1e548ea1f16a643f6b3eb25d68c93a2420209b6b48b9f5026bf46610e0747898e527e00229c1336033769d49b9ea411c4ee33f9241f9b83408ef88976cf2e18d666e0fb16be5ae196292de8a463e187756cca8bd33f469ae6c9db665304fb8e9c5191647dfc06b1fd6e8887f42422b2215d49c385b3a75592b5424928167f0cb34b8608d637dd37af3f2647114127ca08bc7ddeabaacaea9bc0f2e7c9a2f62195d168672df6dcac49d674268fa74127416f86f46f1215b8a8255a5b035c40bf8f48f0dc7322c5a4ee8625d6945e9b6f0a8fbc937741f0a4ee99d44961122c52477f11420f9ee600f4c6bd2d28bffd3480549086d06eb062ce194750cead00c06083445224304365f9fa6d60cc7df41b105d900b8f9b429bcdc3483748132a8ab59119fdd7f30b0934d7991ccf7001e81285c69473f31110e8a89789493229e5d307f1d1bbe329ace2269084ed99e0e5824b3e08816791f90823917b89c7d17c2d24e0e3fa3aed245958bab72d06641351f498153eb11a92f6fceb73de7f70135c9e39de5311f200c2029deee721b779297a7e1993a547678c082f4d6fc93259d3d9651cca5adb81bb05045693cd6e47dc046868c3a11d1306f6a1179fadbce2102c2d4a2383f0fdab0da817305aab39825ae3b5e8769406f43e71129898b65203a65d2873b0cf249386bb36a8746064a302a570d3a7643b46af02086c6ce44f157b79742fa93ddac30b4f271ab47ee4d02239623ab7b1f5d69ae321a275c5556887ca75f0e38d027344f308481637edd176eaab042b017bd4399b870bda3e179b4aa53f4e16be3cbd8926030a510f6c8f6259e3b7ebda7f3706d074f64b61118f7b2cf8e60b40c684791fa57ee03fd4cd0fd84340811ba8dc7f1871d83537fcd01d5fd5ebb4c72a646c32337678c2b2d999a41b2b43e1fd46269e6f59ef3c9624a5c07e53627da9de0251d026295165678e619e776ab18f986093da63648e1132ff427287827b54e102e4a31bb29376250b6cf9c3950ede8addfc1de51b7e4b1f48efbfb169752f09287b8742c37f2bc02b8b2648d54497fa50f2fa9b44ae9106c1f5e68f01bcdb46f73ca129adac37333930792842cffdd3915d5e709165c036700e638c7ef2c3f05cfafbd8ee470cdd856efac72c7232932529c367e24b53079c20fd00a4dc2b879ebc929e5c25831230592194de0c4d257c6ee32bbcd4bfb8b665ecfcfbdf1f11c2331da695944f070f902c5f052781df70e6e3791310cabbd5116151d38d73680a4aecd6059f762834801528fd20d066f9420ffd727cb23fa6977402a2dc4409b793dde9de8cff4976a428c172e1b9b2b1e6112a0ceb90a585d39423a13981072aa8b4845cec95ff176c0b441e28f29338a10e2ba3feaca0aeaf9318f1e1f3ecb44a905fadae7ce560043a1f66da1ea8b0543f1a6a28d328f20b6e3cc3c50ddbfa7563bb24bf8824c7ec799203cace5c963e805364f055e59426aea84009d4e14175731e31b96aece2836c805bb5ff122c25cdf4bf5aad93bf40f84d1b7e349152d4c2d0a00f9080ef945c0796184d43964e99965a172e913a52b4c3b6e7419af81f1f6c742e0d40db5f48c53009e74183ed67d489205c4334c9928dad627f33ce31203586efe2d80822c51dcf3d97500ae1cbc1a9e4c03ac45c50a011485f6b2657a943c00a60725590b1aafd22c1f2e678b0158a7d5b91c08aa751319f6f8fb3085ab1df1fd2fc7e633dc3f0652646a047ece6a8658696c1f858b4bc849dca38f0923919bc8962bcf5cf021cf8c25efc4e6b16b5c39256afb96f9c29fe37252b172f577463b9dd6afd28855e901dc85f81d2905d4896fb37b2dac3e1928ec353682eb813c4025d9029bb695382a06becb3bf93817db44550d96242f791a882c720409ff4c5e62bf0dfb01a3b07589ec5c9ce02934e345557df5ad402c1e9fa8fc2a068d91c8ff2be6ba47f0ca2c46f1a6c7c6bd1ef1002c9c2655466ff62d9155720a3fdd6603a714110839924f7b942d68bffb0655eb17412737435dc91bbb981c10a96ffb736e58187254186d926e43b05fc4736fd44f4c784e9f73fba2a70c9f094b120223437b7b32a91db7ce496ea6d6a190b70dae1cb2226425dedfd854db889cc090599b96e23c8b8d109fa756a9487e4cb6246a967195736fc24a7cfa5d57e7e5223c6999c6e418f769e3a6cf880b279b9c3a3fda5a1fa5142a00b1d6f65f8f8645181becd35722c61a8707440c53377b9484548727828bd64c64a85578708725f7dfa150d3296e291b423857bb6277964c9647b9808bcb878ec9f2b45ade8990dc31fb99b68378c1f822a81ea6f724c56d0553b62c95ee525978331fa6796c4b3062f75255ac8b0e19ce353f65923f5a0f307c9a3f2ddf5701d53d638aaa48c1c0d3d7a2f5f771dae32a6bccb9652fc0b0a21f44d69f5cebfd7631a3aadc053f5a3cd7e5da0a5fe116b2e47fc1d927977791cd63af0e68d76a9d29207ec53b80d54f36df7a8c82132ea0e12d388c825e484a06203c279a3f239e8e1f5419d3639fb879e966533ebf8ba9b3dd5ecd6356bbae9154f3696237673e6023d1996828016c8e20cddacc66ebbc494879bf6a60728a0a38885ceac4b202cbc82a458f2ceda8ee1a22bf436387a8aa327a664ce7b1db76d589b26cbf8701f1cb336e2b5bfafa87ddd8745bed7eeb114ae301c302d828d07c4422e7a8061859efc39834b7f28392656d7eeb49f57e5e95dc56bd98572639aba21c20ad6b58a61bf1b4661c5b9a5b5910f102de7c9d23c533ac760f7cc34afcbca1cbd21edb7e80536c5d3f8e48d0e7ade5738bbb4f715810074ed7b37fff20fee76225ef55b001ec4d2fb4e6d3d8ccbddb9a3a2dccd61e3101422860f2d03530b8bdb074c46d8ce772e4dec821298f8cc04bc9a133860c0c72cb23ddecc6286d241013673e0c594ea0806b5d2067941d90182f21bd413f88fa28f900bab7506ac807c6a43a3c02f0bb94a01f45e8b72222613013bc14bcd605eec9591c0e0110dd9a9e5840e2a659cac8f6bb58be7f6de494d3dde87959f97f96283535b1db26fe22a3c00a21089e9df516eeb47c8a3d550a1fc5388e8faa7958e4c7a2da84c543c73dc73ad72a4a3e6a83bac396bb33da76ccd58d6ae22abfde35cae47f081192c219fa0586e1076cbafe345f8fd8e76d8bf7499c17e24031367e1eae6f457e947877d3bfbf8dc181a5763c4db3149cc24e65b7a70ca761ac6d462cb9973ff2d9cc7127a25fb9620389070fc021214ab9b448b6eed5b1873ab576b7a80fdd0f84b750500855e20eb264024034c143707563a2da504f1f068447114920642e29371e782a714393a6813e59a63643026a48ce3d9f10f986d15c72f4edf55397bdec10412d5ed40f9311c5fd8d74c3f4ff8c1a5b6046bc7de394399449407444d35b68483afa3eb5844d6a737e1ba5ae266e58387a9d2ce79f1cc0ce4f65061fcb49549d0240fd4261db8c4f29d560cb78bf5fdcdb3977166a43b2027c052d51f8784c101bcff9f43f4542e23243562e17749185e80171cad6fb1eebfe1136e94fd6abf8b546143f8847bf8706d62c8b67eb6248f29a1dc0baa52ecdb4f77d8c737cee2c3bf25c711963de13cfbc83c958b458c1bd9a896f15cd3f97b2ae3aedb91c8090acb893a1942e6baee1a4fb473b9c66f78f759071fecf26ba64a556c0a48b018f7212caa614cc466702cc3ce1235a19f840e7dfd9e7a8acd9c83559f541cc856a45a03051e64ca57bf54581a92725dc2e10ef7cb019f4f230e9fbd38574a4cc4c7476732c6c55e08eb0893ad96b50b0b93000d22d817701bd95f73474ed28a739fa294f1505584e1454aa6b7f8e1fd7c4fc6afa1725fa4134f4719f5456e057a0e6aa97a7aa395cc964be56ff842ba3561c6ad9c3c37cb8f82b327ef2c52bca348c2f76b2fb1a0eb34bc8151f7db3ab0097c5bd25d5d1564f3fe18478313ba1379d1b5edd68e1915534c65f1a9a6f88454f184508dfef2dcbc6536023c37509b616603817e46d17f7fcd55810e1ff51a629952ad1874e18f76cc9659027a5872fae4d68bb6f317e533213abc8a48e162bb22ec763af51105e918b122bcb9ca8efd5c6664805d69c5896c37a552342f832d8f188d3f0fc7106d029bbd2a7cda825052f77e1bb4ed9f5f2da9fc7925585e666eee6b0abfe39b77edef1c5416c283a9d6f4a1693d4805c6946acac936c62b846ae89e5587045bd63140b66f3aa003df88249dc50a3c75442eac33d11fed581591de8f5381e6a0efda090b7dd8da253cd85553bb211b0f6244a49c32b6e662fadc67372aca076552676a945aed3382635d865dd5a373477fe299eefe1410e9dc7087bbe354a7fa0a91555300fcda50a9eaf4ce4fce803caffc346d384e102fd3c8f3338f3bba804fba9f1ee2b552ee8a390e7d8000ff386a38344a5350a5994387d8d4f7a0f39be7d9644183d5b91c4d2aa2ebc2fc06d7b1607ec4d7a227001ebe2fb72df8d22e7b702af5074d3cd657bb9d56ff8057baeaa76c14c0ce805f1ad2132a430699d4739815a63aef485e26b16bffdd9b48a565176b5dcd83aa788ff107e872a89c13780e0f9c3780fbebf5f359f7ca50385d69a3c41c84a947c073665a7ccde69b40cf2d7d2f69ab48e56a9368558c3fb68539c4f0199dd082dddc75c695a0c5fa88674a0ff51139657f03e56bac3f9f82d137445223a311e926a3d20ad5c72f370522c0295e3c16dc3d77e03e2aff0b648e0450ebca0ea1d557c886ddd91ff0af6caab645938e9eaccc5e4bd6c84a7cb0a13e7d2c51a9e973d50f7b675b437ae9b547c4f6cce3883dd9b428281a29c13b466e97aa38815861072813bce3d3aafea157a2ce1aaef90dff5a1c00cf3c66144c7f2e98bceeee2ad32f7ca31526166e77a077a4347b808f2d50776360be611532dfeda416d2702ce8eda5e419e1e877e338dcadde922720d415a143e270b370bb168ce722f2976318cbb494f26eba3af9844870cc9df3bca8cd3c87fcda967461ecfc16252644cedc66c18e59e9e07529eed516822e9f7df9010c42c591405e98ccf622783861b879da5b0af45d3d4e8b16665e385f83f15eee851822fe5fc55635b09b62ddd4fed9359d35ae81dbe0de127adb0b905a0269d6a9e44a0afae36c31ba2061cbe56d0978378a8924fd53f02029b92a40a6c90787a40e06ffa766c75217a01a2437b5647996b20c4a3b8255aac4a2b510554bee259fd867a13f2f84e0f5269aa15502bbe1235a0e4408f46013ec5ccd16374e9fc31c8463cbfab369055aa4fd296a0eaf4842a3a83683c8b7d5959e94460ba0a8e4c7f0e030695e7988684d53b5747a0c2e7770fc33b0b53cec3570e5ac7d0eff385d9a5cc83fba4eb814aa1ab86a892276b5f1889ad9591b9756d97a3fe27cc2ab10feecfb43332ea19ed7a53bd81201895ead8fa8a82c153ceeb0ee4958b8500432fed305fcb85a84eb4cbaeeae454aaddfcde608a1ee02d1dbb8c5b5d1230b3f230b07f69f2bfdeb268372685acd1a99ddb5fc4c964ad2b8eca324d44b71fddee56cbb1d01291f4e1bb250784877ad6e61707df0802492bb74072f3bbeace5454bcddda28342f8021065ee8c85b9e7be5b0acb68f6362cc19fa26ed57e3f8055a0aa4d7c1b250f7d5b6b783d9f7d627eb0e08b0ec6c63e581fb838aff5d8cf0b36013b10069c875c8a5ecca628347bbf3ea19fd9b362f0447368d06c3413e5ce853752501c720c83319a926b36291e89e359582687e62eb5694af1f013208b813008f24d4e99a7965aa11b8a280ca7601d0d81d90ae6ff45c9232a8c82d1239f150ed11aa5909e56e565ea54a90e39c10ca4d0f3110cab6b05512ce4ab5252f9f78d40edb1b5d4d9ca6fd7d1d6b299b0fb74e5131cdb558b4e8df473eefc0f89931853449c968374d50fc324c796f0ee2ea08e866abc2be5701e37ba85bce09fb5a035481655462b92981c3915a827c833232297214bf5975cd0d08241aaa81a501905f50e5cea4f891376bc1177128ee35f4a631c6f100e81f26fe8794a2df4f2be9b5500559f8d6c5d17458a158408c77a6d6412c74a73a4fef5e3569e9495d4c2d1a2363e3d6c422b71b720b49ae558e097fbfb9944fc26f30825f60d4a241466f579e9ef857c81d799d9ee04d58f12e76231d83463af243cacdfb69b9c7d48eed0fc9fa5ea1d8467436ceecd99b87dacb80ac290b299cd9881410819b76382963f8426a8691c49bb1ae144316cc3d340178b73152cb1ed756341ba892f2405535c50334563d1331540c9a6657003818d53ea74b930ca53b6842fc14a06588b5ac4e2f3c0b77046fe9b17ea2d3fcd95fbb1ad79f973e343fe9eea4a7a36f9b53a908ed49212c31bef910b752a4b19b4c290915af2cf8055f958e8165e73d5f903e4d9548693814f067ed2a84920404e2133a88d884e422899d59db51b273df98058e0ec1d3fa7a3d2deaf8adb45e2deeafea092c5acc15b3bbe91737a4601d036d16e4e461a56b3aed654386d738d16aa2b0e161e7d6c8ce211a3dfeacf0e02f7b5e2014db9cdca435d9d62612b04fd8e5cdc372b91521f72015fac4a666e3c068d006691fddef07c9edcbe80e5431cada78331bef5d5728f21fb0e6897b6fb0dc82d1e3a85dbe9ee4","isRememberEnabled":true,"rememberDurationInDays":"2","salt":"02b4a9de59a69fbea78d16e812afee4d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
