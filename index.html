<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked Page</p>
                <p><p>enter the passsword to unlock the page, don&#39;t try to guess it, you&#39;ll just waste your time.</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Unlock"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"3132bf200b03ad01d77634253d206f2116b576c8789c8b6e5b2aac0db6d89bcbdc439e110977180efe5cb590f9d5f41b5b3e666522b03cdf5c14be98124b653d8c973f14272b74742b847bdf7adb990c8afb7d10f03aa50b3afef3c663fbeed6b873eb5cdfb62be00ece730464b21f06dfd2c5fa5ff6ffe4d79bd92312934578ec7d0898151984f784f21ec547acbdee6ec5e3a535da7d334d4a73483084a658d1680ccee8e8a21d3fd09d12328b60f7731a8a69a57acf495aaf61fb4dd5c6e670165bc2b5b4118773b895299a771154455c9b9987a805cd7b826a65543b7fdb2451c8f7f4097d51c6c7b70af4e0ec2fdc868d910ab81811eab3fbcec53ae103dedd50db52f010c3cfb225a32fee3f3bbf585b7167a8b160b125e89c3a09a12f05fbe5d8d2310179f80cd20ed35fb1441802d8bdbede59ad86039195db0b5d80a976427c0b8a483221fb639ee5e13f3c36d2e6d8c4e2a8cff64505fc303d3540cb45c37910af87d2ad4bfe28930ea4864dafbc1e7a85005bbebffe2da9215d5e4578833d0ae3742b873ffa855808f4184bc8a180d05e3be87767e56abe9043df6466c1017b972601a427ca5b33e2f3ff272c4755d02469f21fcd22b0b89afa8ef7eed3468bb08a70dcab89e03e7e469960535f613e48aeb601d05c4371e012bc739072184d24e783ab20a2a887855ca9dfecf2342c2303b9a1383b831638145a043677bfbbc2cbb94f92fe54d4ed4a02c173254b728ce5e00995224f0f94efcbbe354eeef33137884838f48753e34cae81be4fc8fd0d8966ca809768f509d8ce5dda6fe485004abb57f9b8bac81f3472c5aad19289eebba40dd93dbaa26b4753eba3ce10b55eb3105fe42dc847f1e1c728fc2f5ad5ac1808d2e405b1b91f181386154016b2d1ab3f2a82d5eb08ff8744595be40be394914606a3f58137d5881ec701fe242312244cf11844a8904794ab1bf026bcddc9bab75363a5da9bd0a1b8b726b3bf9815c1d25be415ad861520ab0c8cd9ae38f6e142e32b884703a167b2b8418e2eaaa631449db53e24e4fb77490a51065b588c528aad9920f27041ffc2a9192213afc35ea44d04e52d0f180c944a2a39f8b1b80c145309de0ad7f879540107f58c03b5702a5de99d25a9b63fac8b6e966137fa13a3562f2e1db7226baac677a891b0e6350e3ada0e3f989331727aee02d014ec8a79587cf80d0a2531f6a953ae3fc41d96a3ed9616410b7211b04cf0ec66740c0585878beb61e1e358cc177543556a3294fdf2af0c86a1a006250ab501eac47faae1d2c1e4da07049c959931ad302d9e5ee7354e61633764a7b14ff391dd7f5c2903d2816d1aea89716af59450d4ae3a666d72ceba0559b1ba00f951e81714ddc3bb6648c224897ab24cee87fe669a2cfc105d080f1468e073691212b5ceba3ffb2f9272adea704d31a5a88083ac688261692c3284f827777e42e296c166ad752fafd4e13c01a6ac3e60ae4d78010da34eee5608737a9f05d43357f61df16f1d3b6ea334535823c11b2a157555b5abe4e71171f124256d945a0c24fb2bb02c5f83076ab98677689b81ad798132b02fb8acedad02fb25852e9f2240975eb707fd351cf7eb892597d8ab623493b2c35e5ef0c94e4aa56f2dac32271449ce1be6db78a7c2814b2127738b7bb2068099f443198de049d18353235c5553aeab4d519f7fbcbc8047d4ff5f6614257f97f47e31aaebe76c40f4e8f59de7fc7b2d8e8579edf3a89331af06b36bd21ad9ebafd51e2c5125df2c51bb7305d854146ede481ebbbbdf58dabec9e792f0b6f4360245af038275e71b6b67253747f72eb4529124f63300719df713763a21dec434828771e262a2902c52f684fef116790e8dbb9751b26d74bb3f4a70426bf685eba4e8c57a04613cc832704f8dc541cc8a9637a915fd9aa250f0c6911941e23fb8f226376da60e61693fdc6e1d71a41eeeca1c7abf4c5f0b98f3708fa60605722528fc7b9e09e4d111000519ceab3b239a63f57ccb3a20dd8310b471a4010a7f4c0143f2520e3b59bacab4ac633f32074c989fbc1364bb83fef2a2bc4ec8f0b5f04959e7264bbdf6724717e2e7ad737925edb1fb6524b5c7691bf48b54763f83f0b57e7455e9bb7c798dd4a5d6143b07b104ae4b5b4c5ef7e4274b56ab64c6f2b97b25cc111576b9c435c415a295cee39dbf24f359cca7d523a71aa3c1fefb3692534c4cf1383ebf18a4c79d0c4d66a024b03fc7280c51a483a0f3a3ba676abfa5711a9ea74cc6e31640663f10e35926ed331f90d51f514fe8c4fc672e858e4238a478fa34922e46622d2b5bee514fb97873ddd1308d09dd1a7abf34d31cb78dae5ad7cd2cdabaed24bd64dc78f97c1f96c86c09d94e9b053e48a119bed705e59e01998b2fe8da751c01f7d964cdd840c4d776c3a5c4417bccb437c5b8effdfcae3d8442988c93e0b431a70d4465392cfc8f3693a6bea0fe275549b471dbf95f047280094f612e7687750ac5c172e8c48a72304212c0d491d67fbc2dedbc64dcd9a39a0720b0601a20a0450728a368df634707361bbc6046e10eeb5a5433488df4981f042ea76c160ab6e62a7ec8428f26f972af20f8ead882fd90d27cfafc37ee3d8a6039d45772cb63757851acd4f35f3709d42ef3129bfbfd1bf1ba4cdc7a465fb7217e695d683c1652643ca2b02f961064f89f18ee6968383d03b79edb7b09650e1e2990f516d51bf184e4a05b598264aad954575efdc5b336ff0b021473987e2a457ce2c18b72f5cd0882802e2e0684272e6677e2f41c613051b5c32bb7ef5dd6bee4d2c71a0d08627e9ebcb15a117d212eceff3f30ccc7fa29de6309fd6728b155334b3ee8bc21cf7e5a99df268fe6a31ad09b1d31eb7e4fb3fe8a7b4d69e77a86cea2ca8b85015d57693a18380b2a4c03bf7e3b44955df7e67dc861bd4ad176a561ad5c9df05ca4420b1a3f68a13179771d691e7ce5481796673d9ffc91834e001db5e9c5d0a658c8186e2ac1a5bc124d3c9f5fe371a914298c5727a132cd9d46a3fcde7db66880f15b457f4117d189bdeb8010b77d1e506b724211e33edcd87266e0bc55e449767c8f94398e3d1a9f4de06da7d6a79ed249d9d465f171404fb12151667045e7a8f185366a67857cf13567b80c3e22a51aa9611760d95abd228229737bf6250f6e708f0082145a3cf4111c87ef420dda4be6db6fcd320dcc8755b21f075b86c9b03d79a7c02cd0acd3df18497db464d971133b5a07b756487cdc09613066962a1cbaa496d82618011dc28f936cf5b48b86845e82952f1aa20083d2a9eee0ca52008e8be0e5386f19e4e3000ee447753a0b5fee00b48864349a1f61b4d8a199a65f7b78ec927d2562e550dccb3071deb7dc742883c94c2feee29e00dfa5a7470c93d0e6ef42171f6d980c0deb7d18e5fbf26d6c3d367ff1e1b9461f7d042292640c7b99ef47fcd69c36fc13e48096fa437d3926a874d19240a53ed780a9f23cf07e9cbc05b5227fde7bad14f3e596a518dbd9d7897f3b4bb96a79e0b7cb0d5e6227b9c747e46a2fe4291c4de7313bfb1e240be5a62d7c367d4b00cfbe487f7bdc294383f6d9577394382e68d02d512828818f520a38175f7e87c14c53e6bcf073088bab948f3df2e35d7c688d5b58ed47aeaeb08a0a226a71dbfb1bb23b35189cc490e07438bffe584d2b492c0b3b9be83db6920f2bef17e2285e4f85d030df63c510b6c09c9249d82c2e969139769a45e0fece21ee66dc62cf6369084b3f81d490e67d83ec0c100bb7cdf1de32bb06476299ded65a0ac33148ae4cb8f508a54710033064780f40b96ae678c70e75dfa99e0c4db398e97c31c0e67f98a575070129010981374de89ec81f74477fb97311f8ee296ac2fa9bcc0f851dd55b5d4543982ad720997387051d2d09596f0cba705bd4c5eb40f5044d391744b1913a6c14e92f1e9104099f4c4f2f062c2af16bc33d69885b09e7c8e7b9bb184157ec01f26efe175c46cf2b56420f245a1fa767b9c8849860effdb5eeeaa72beae057ae683e1b921cb2b9ee2a50091097bb9139ddc433c9bd256c95cdb6a8a4887c86d2b70fac9dba5ab9a22c66188e85b87e9e6c0c75e5cf504018c087dfa6b52fa98b7ee7563bc5637b18cd4e5281e6e6f67800df979abf49da72fe77897cfc517a6d139447296b8f12c8e8e283fa6794bafc46cd4f129df20f72c4da17cdbbfab43332ff50c3614c837dba56180f9bbfae88cb4f5a51eb9b765e307c9ed125d1a87e0fe593de10167e0f71432842aedaeb1f91b86a9613bdf9a2b118f662825de0623a3f503133ee3e86c90c8233bedd923a51694aa5b6f1c51fab4ccf2f5f68f7cda055e22afb35e5dcf99d4ded60e2f0e617cd4720c5462755f94b8b36119af5b3f348391d06167ea0d83a99fd21558cf6e81d2aa9095cfb4a5730202a0bfeb8570ed81d5178d8df4fca73974ae3d7948d455bef89c787f4d93402ffb8c4adce0a12c3dae93102a8746a8c18dbeb73db75b8843c90059c889ddef3b300180a4d49463e3abf9be9e9c85fdcc1c2b20a279ba2e2f3f2a11b5d26337a2501b77392a5aab76982f199fdd98b8f528d34905788e4ad540807e5caf468fd22785d8c8aba9caa84bfdfd9e52cacb3bcf2e601fdfa7f3c60fee6a0afaa180abd72178b1047586605d5c80457c2fac5fa672df6154ab79d418e9557cb237f7854f0a72cec12916e783082e827acaf772224ef04501b6cc045139e2c9ff4de1f9899d909309a4080fd1a49be31f487bed121103052de72c75d5053e6c7573c86a31cd1017e8a172172007ae9705cd75dd27bbf8db80900ed2c03be846272e397c1fa88d32404b0bb2d1b5c3228dbd2a9a9f3e869fede788c80a50eb4dc1cd7358a537d10254dc61a879838c9a326b20f84a85c56db21c707e41c25f7069c47370124feb810d0fb9c481aea5a2b531551eff25fcbd2cd191f120eb3ab9f16c2d91292bfb562b3d9dbb20855fcf45344dca0cb5dc74903d7452bad40a2fc2c896916e0cbec1caea3c73249caabd53a21145c035a7e4146210b4f90aee45fee64e0a1047199fee54847cbeb4dad3c65a5599ca86a04d294d6e57b90e742cc8b86f1dcafa0423fac090085a36e29d8beb028931dcb0e8f60720813efbbaf18b6ef322689e813d1d4730311813da7c6df9205a2ef691fc9692e0f8669b7f84369475877323f873ba619281667acb3bbab153cec7daeaa13588fd7c1447b860390da19ec6785beed917323c2d82e2c846b01b9ed3640a95e791bd35c9570eab501aef85ac92b8131554f9310729f784e5377f8ff2287a76c9c715c3ed3560ec6f5b861dac331e1247e8c40280e94b3a8a48a45122dc77810147de4e7221d249030221e696fdfd2303ae174f51a76de9ddcc8dfb339965d3a3b92041724da86dd100e3fac7c3107056f15285b4e6236048ca7bd0394d3a3b5664673712a9d8a963da6b14025520639e21ea761d51471651b40c587d824b6483937f29890a1089ba3f47e03f4e00afc4458cbea9c75003c7fe96b2aeb02ce684472c07b795cf3662cd389c6c9fd817430f9f089a7bba3632a67755056b621b2cfa04952a9d296498893ace61d46142b769850ccdc1fc660bb9ab50d22a358e9c8dcfe118f1c2b58f1ed21d78891a6890cb54e9a8103ff33e797b659f3748361fbc658f5e34d449ab371ca4b3f3d7bc65dcd89a19d377368494d48cbdc0af3e9ee9ea0f6b17f32ef2c96c66f86d03711e15bded560c2a1db05df00b3fc6a060503e27d74ca2c4ebd90a06e778f17eaa2ba9e595362f4f2cc0bb923e779db676cf31dd0a7910be0d4593e85cea4cd06905c14d71e959cfcd1fb63acabfa3b1a46208ef916ef115b5adabfc7c1637513d541c0d13edd18d8aee66d999a94b4a142b14bfb5c45459e3a8a67578419979c212079ffd85d7e1331bc0ad0a53640b861dde23eab0d8427591b12a6e7ee13eb079455cc4089407cb5f36b0a4509a70fecaf077a70efd641da844a063b1d1922616bfca69080f0dedc581203b7a717c853970f5856661d51b26d2dfa7b6d828df580aae33bb92ef3a5693d2ff0ee990114244d31b69b79197bc2667d71b3425c56fb38d7b6c3b19941609e2edd88a13c353d2c51fa1f079593096785d09fc251256b5c43a46d54fa740bbdd259ddff93571378fed9b65d3006c9ee2ff6b83bf34a73da2c5d9e53e86fe3150323383c5eb96e6d46a0b9996dc62b80d1145b3ef84fbbd73f0f18099732882f2df3fd78d95808a2929ccc7ee9c28bb519dd693fd10ba629d77ff00c72212b0f857216e707e55d0b253411e2cb557ed616c704f473559052df6f979e7f6e0e9a9a0d9add4e4848832bec4f1e210fa3f7a668e30524ac7e6c8a60eb51dfd5d940cd80a22557cf39f4594abf159d6d5ac42abfe9f6a58985d3f71d3a363046e902b99b4501ff31599b50ad8c8ef2a5cb0d3760806c01ea23efb7851ac303ae7b93c3d0dfe8e3f91944336dacfc53be019b708c7b9609dbaea174e30c322d94ea22616f5990a5341be22aa210313ab0614f9ebe0f7eea4be197ac6526e0a9d04cbb43465b324912cc694c04c2504bfe4252b34f97d8ee485b96eec127747c13587b02090e92c3dd6954bc56825635127bbc373feb189e475394b0c527a946911927e0434ff4b04ade38e8c948468f4abe66f91e66eb676fda888536ce8a3696ced37b3630c4f6ebfd4b0da43464ead5373f605686caa1e44f8ead750746892f4f2f2fdd7ba62e9b7cd7e19b998bbaf9274fcf82faa19c29d7afe1bdd5f547ed880a463d0f1ba9a8647e6aa98f269f57390dc7151e781f0d8b70370bc9ee57c2033ac9fdf21f6c24022080bfe0ddb8431c3203cca8bb2f529bc7bb31d19b0ba8ab1c6d82d51caf7daeaef62c8c04689ac49451f1091be2114a2007a5f2191522ea98318ce90612601e42e30923b511f319a17fd4280dddf844c3912319c5989741a0871df37683c6393e7bc64fa817ef7dd0fd89c59e9f38eb51b899b3781c54a6b82f0cc794716ccaae91c403f607c64b1e3b30d0956fa764b1549d0d7f7eb67ce76793455cb00ce6b192c930f2af4c5d9dd61b3044c3708b8b84a04a6e4ee7451c81c45563f808e0c554c48e1e5b5cb5f0c97878faf6cb166f149cd0dc5f2b1c5654381e8455f60cdddc47a47acf11d094cacdddceb85c00d5d9e411556b563355806ff4ebf63dcdf9707bc703802204bc200fac212eac5b313a09fe15456eeefd89ac3061e38dcde97f1fe51078c37e59c6d3a6bb586924787b9e67dd417d1e6bbf5747ae6ab1bb1934916269d2350e6d3142b3e69d00241408af6451e3acd2fc38a1e8ce925d925799bd4a76eeb7c87abaab2133c6925dbedcae47ba144cfd6190428f014856e37cc6c837ff34a00016e43dd562986ea62ce9a37d00e1cad909a0723edacbfd68cd3eda3c8a28d50d1726f2b0a30f6adca4af084026fa8f5b057dd6bc07104adc8ae96f513674b75c43c4f649df46be744dd0f1d7226a8a622155ede11d8bb022930f949b15750d1e5b1263e48043897a74f3be5229fd9ad62b4229c92d6717248644f2c670d6e62556531722ce3f53b466b248c03371ae55034f7ff5a5c5c87458ca933c15e8929db92d8950a12f1f14d24f2d1ea57265b78323daf3a79fd8f71e29886f61087030f27b5332f48f561f9a842e4532f9a62080664b20a5517c20a87b5e42aaa1bbabb016b3301c24977bb848d5a4b052d5024e2b591f99a730984aa9cd5138aada8d92fca06da5787a78e7c2b0810cdf6fc8cd64cf29a0dd5dabd4a801202205b02e7c3d78351f7911e3d1ab236e91a257d05a5b03ed55da4dfea600460993b7eb394fdfa81df9e37b1e20020f6799fe6c1e03571ad2fb61dc17cb5a011547655ccd4b07dc999be1df9efd7022a20d31000b5d34cb4762de4063b6a7918177cca9f4a548ec5321e86e052a7b958968","isRememberEnabled":true,"rememberDurationInDays":"1","salt":"a2c880b4b2225fe35ce6d52b9f99d461"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
