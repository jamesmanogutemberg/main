<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #4CAF50;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #43A047;
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #76b852; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #76b852, #8DC26F);
            background: -moz-linear-gradient(right, #76b852, #8DC26F);
            background: -o-linear-gradient(right, #76b852, #8DC26F);
            background: linear-gradient(to left, #76b852, #8DC26F);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked Page</p>
                <p><p>enter the passsword to unlock the page, don&#39;t try to guess it, you&#39;ll just waste your time.</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Unlock"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d84d4c1705e9b5c11e37b6367211bc495ed2aee01267db4aba423c7d42572e71171b09543f3e91a55d335b05bd6855cb16a9fa24de03b8a55977aff96ac93a333ef6135fe5e2f0fb5c9e8bfc74082d2b0cda54137937f538f0512550fcf9a4a4d45597725032f2f762466f9e69004b03fbc2bf02037db6fafd5b2fa541cd7177f4285c9f8b56304e3f15dc6c483526013b0d24783fa6ee973a438dfcce8ad72980cfbba016d643b54801bb7c8db2525b17c3aab2844af1a3a05e537124e95e0c32da94ee42fb63770b755c2da177dbfd305bbff0064c4a91b3c2e5a78a7549e364fba50d7c7a44ad05e0e4b0026773e8648c1a465000ceeaedf6efbd834e091f48f5f2ede5c87f34167571838864c6b328d91b6033292a5b5724b2d6ce8b9465a4c0e0fbf7e980565ca6c7e8ea304d02dbd01466097d908b58540089b3616a5a24eb052fb3f7252e80f595e07a18ea66ccd7a6e6390dd144d8b568328ab07945ee01f6e7bb9d14349998fd60383012ba2169537391b8c159efab18233c979636a581922fee1183e81cb80a23805adcbf7befb716014b964a4a72373a0fda7a6db80b93ab8cc0397d6ba80819eafb7e89ff5786eae062d7cacd2946c72158e4bf0a9405bf8e5aeab4535b1c49c382293051fa268f85d325778f2cf068733ba328fa3fe92eef36a958e5d43437550b36cb5c6cecd604b2e8ab752ab22fde5130161179941789e935fb2c37bc4135253046c9bf84c1391e1afc4986a0493ca7f926434696f16cb8b615247895c4955b1b47e55a1b06bf0b378be58e4eb3c9513dec062e234cebc8b0bc133c76277c314a58b0f0c70252caeddf577fd78c317af30752cdb8eb79faf67bea19f3dd4643a5c216d05954c62e29a63d636a4b1d73e0d669e8d7cf8ac24d1caee13ae8678f57c53d41932fead52f3ba19c42b294b435e114d42945f46c6addf2163dcb32e4cf10acc2cfebed8e3d97a9c3e454e3011ae340b3c4aa15d1213a434ce230782a48657692f9f44962dcd1002386ca5846415945bfed2d6d38b8574c35dfacb34d359a93151a513c010ccd731bf9e46ecc0678581a27bbd21be1ba1b8d9e82a96d461d80ff5063b28d76e703f1be59cf84aef3268dc29ec2f9becc32ad8b2e7de926d34c3970dc1fedda746dfb636a51b86f7dbe2035eaa4188da698c45078a2b6ea57530aeb3d7ff327d9fda99feb2038e214f58a9c3522b773f39ef219f20b4fc95b5b75c7107e0c70d88ae7595b5b09bd3d93387d12cf10fa3b31a69108066ec51cd4443517835f35a461a817c518046dd93c5df4b894887834f81ec231ae356a48d4ed6207a15d032f0b669f33a55938f5e929e4c150fee625d2643c152af14f03bd3ed99fdec13305b11696152c6d8e7c97b2bae1628120c76c49e565e6a0342b15e48c393386b9cfee6c2b85ca113296cfad9a21c0f2ae687c53be31b5137cd799da47ee4c803d10b5fe4171b8215d9b0da37e3328a6d3532c947342f5f8ffd4dfa22e035733ef29bcf498e86dd81118a85faa3d98da7b4b6f8e201eab40d7b7c8988003edc46db36b77303334b288dba2a00ed72898e1401d5b57598d1e5e00e23665ce8d13b89f4b7ecc21dca29158d0594868757baa1372a8d60beef49a4de66562248aa335dafdb1b2de3a8d1ff711d3b5abab0b820d3626b54f27751decdff60406e93f5cb85a42eaedfe5de3082beb845391c02bdba74f0dbfa740d0d17807dbd48f27ea9851b8a3548ff88e92c83012eb5dbe29725c7f832430c85ad34d910143f53df143ec4b7610b4a2a627246209a6f7a85d62b96755911f05e060ebe688bfd405ac059ed5cd5b85a2e4eaa4ec59e01b1e47258eed3ec35d89ec0c724375db25ae77d764c10635a87f2bcfc131476465560cce356e027948eb6373d68f2689e831497e459b25959a0338a0afb04d818106d3882c95fb6881ca7d05476443331e1619fecb14c092ba7443beebca9be0f163b815eddd19e4d581006d02d229257ce5fa682af2c88934e4816811ee11d912bda9e8721a15bd45a348dab60241b7e7cb5315de1ae7e1e8a547b38a380fe8fe433e240156290ce891de2f2cca3935d9616f9fd0c8a7301cf67896b600f9322f954da700ba6122967b31eb33289db37672c0ae2e070b56047a601c95d56866e0f8edda8aba92b4832d12f7ab924de59d6e1d7cf22e21bc1ccfc0ec431cd3075098abacd8c4f58c428eba943cc011680887afd7d7418a408f76aeb4c396b0dddd8a5f0b649ecabd738d48608a036cb390a1382b94927bb30f2c3ee67e1011ee3d0c0a5743112646538047f38231c3c3674d07552d58c22e592a5cb3d5cf2112c6058e7ff8bf8930740b69b55869f66864742e2241b25cc7d3e2512c8dbcaa6e7f7b1b2d9bd7a5992495a6975c47f22fc4e8337cb990b53262da6bc72a8418e798a68cb0cf895ed1ec07283bd81908043704b4a8e652b9908a0391bf70fe81e4f97a68af49eaa7020f25dfa9ce678795fbf6e67870687d3970d3f18162262fe0890cd3aa138d2cd65132a53f34add9183ec7f878e09f3b21b51d2e439e2af913561ff1f8f3e65c128f196c907e85a91f2a1109d1a4101beb01c225953cfc6cc73c70a8a49b90b2106f24901b19eacbc659e0db950d9113cce6ac68d486b2150178bd25b5f775d661db96f56d07f93a88d632b51170c78899366a5354a5fae33e9c46efd6bfb7f6da3a9d0480d11eb541b63e62997b18100058191856ac5f4493098b321caa5e751255a8f9e48a18a9338a39c5a429503dd7842905c43e9f7537a8320d11d0d8eda2c8f8fcac46edb618d954de99815faa24212db8200cc2833c06509746a72f343017a4f681efb3d9c3b1f911faeb510fa8bef1bc9571a99a7f5bd5c024dd933324d93a53335f2afde6cbaf1881bfa55f99af165dd7c027d0795b0ed35a9be872b963ef62f560d1d13c69c836cc96c757c3de4a790d36d55752ffb83a469aa6eae5e4e1e893818e58e05f8ae479505141abf43e614d47000da55039eef2a9aa4c741777b0df46d405a23d90381fa68688d37cc281458a4e6b287b284337844e1aaa58bccf7171f1a32dcf788212635e9eb866739348a2fdcd5185afeb8c4ba870a77c78d1779b0054d3ca94e2823a6e179aa3b3bca1456f910cd432f566a661cbba07fd8645270c15f7df75acae80cdebcf9c9ddd6cac9c21e5b1a58b8eb93949f7c57ec4fb6cd2fa54381bfae8acf95939904f45242acd265f0e5efb36244d34c7a861e060c87d3976635d65f63aa1eb4694b7326fe1df71cb3947a969ff91c178326507fac83b078d8978083764af340f15f35d0f41198da4e3ff06bb3cf7a06f53aba11e91715ad01679381cbeb22e12fdccabd58d8e41276b26bf8c5851a2355642f28eccd64e6fd11898a8d756bf540a1e5927ec689c00c726809c9fb10432e5a7372a6854d2ce3420ecf8bd6383a3c97172a97d66d8162466e03b046717a03806931c5b10c39324af708a3a739fa950c9ea5c50f666a72784765e6182bc3c4f76aa9897f4adc4951c9218d52e4a9b307802f813a564903cadf40a2441d0d125ebea0b53a9a063080e4ad3b3019f16b2273591408f716be3a236ffe3b80fef320f7ab21c12d472151f60424f7d49159be07bd7b4f6e1e66d200c185a48e978988a46e27ea39b184992d547e6a87a5f83ae61e10ea19bdaf17da9479dc7bc9cc7fb3ddbf68bfcd61137949e6da40326a9826184202e84e09c2f92e75b1fb423c0876746866db8dcd02b3a608449d14e044dd2013f217a17b16b6fad2ba4e8fca7885b9424a3b2006992c5cea9037a0c466391d0847e4ac520236c5ba1533c77aa1df131f6895dd38953570f0f39f4580d02a4c5af62723bfe45ed5054c2e0e41303965d3fc2c0f91bf1b1bb98226102604f2cc026b468824144779bb992f47bd199bca762ea491c6ece7cf5d75b9801ebb1031ed238a4b2141276027585c4cda1ae61c1ab7467d1bd5828d7a1ffaa4d1fa5adf1c10e1fc3102bd44ec9e5dcdcf089d974b6cea52aa118131a1250111a05de486f736acd09ba6f5980def60cbdde1a3e69596c5c6ed2e002ef99ed61d8d6a4469bd8533dddfb99161b96640827fe2e51dd9cc50573928d9085395323442c9d3dabc4c5469faaf722d6822d6113312b67819f485d6d9f240eff0f133d5c47f35ae88c102b197efb94eaa7af173d338ce481e15a226a1301550ad341aa5b9fde06dae0285a986e15c4bf04f69305c82e643f91e9d61d9162041b38ec620f04f4b02c07f81884c22de159676642166d227a0baddba5dc370dedec24a0d441ebdf065f815ec1ac29c06e2c9b317901f30e2eb8aa543e7ae8c571874c9e1ae6c0c37ebe68261260d46317f3650222c79aef30396aacbc9ec630de178c3b90d652ed85c5e995784a669db63021d5a5b7e7d5c4f42973483905cb9e3677eabbacbaed632b0b2ef41e737a016be4a49fb0de6ed643d3fb18712f755df032181cb45920aa621986e519914928f8542b50acf7f046f8f2db238a77d1c1f4d7bf0feeca01f97749175843f1b8449891c7b3abe77da79670fe688ff072d6a866c5f7f2c50a964363159f6ccbdfd91e5f615e069b51656e4a47603ed58b37389f5452ca72ac52a56b36668ccf626ebf54e0a40e9e789b4f28d01983614c776312c1fdcff6d90970aece01bbe8750123c3bc77e9543592b4c164b5409fa924fbab63dc75b0be2b007f40e4f874515fadd73f8c29342408887335c0ddc1462b823afbbffaed4ae3902ff6eabc824482f3f89d7bd9a39e90ede1b19a852f54a2b5e926f40f3e2f2ff17b37845818d86d7edb3c3e4f9e783a9d6dee928c64a389265444de177e3d2755c69620ad37a93b0f6e08ed11c319d4c2c735a52bb0fab4530030c1314a55b5e5132934975a04ef616c3a407b2a9e769e8c154b9b0668b9b0eff4c1e0b3f8785ae62d554a58609abcf5fbe4d8077091e15ce5ae68677fcdef7a8b36e27acb652a00c975bda39fb4d48c4f62d7b91b32285186a13ba45e79740a3f3f34ba00a322747261413823f72122cf937131add6b04a5c1717e7a4048bd7df2761ccf40637ccee046778387f8da0bb0b146f612dbd4e48a52e8d2863a273e96d71f4683b5de8bfccde097ea5d357b5ba5e576458b0a8bc7a9d0f493363c692d8c79e3c7efe2aa9ed84432f2525892b867f04b6540dc906abe15624372260dd936dd6933b6424e364d22e29592389add4e1e78bf4b05273199447a97399466a72c7e6fd01ee5488090786c369c397a14a067b25afce92d8db4b8d5b9499b3f88225095c64bf5758e0152c1ee6f568faf5c6d092718e0e3a1e90abc9ae1c8d4a97b27646464cdee5cd86d417cd68cf9b7c750037b0fab0c8462be3420db647934063404c1124aff29029f508e33ed2ab54fd34c729bf26dbfb8b46fd04c8a7d566d318ebf66626c17250987c4f73d7bb8553b3d1c5da493cf485d899ae4366ea069050581017b6e2dde4bd713699cf4c8d00565a55b1538b860aaf599ce107e9959c7def8356184f20be8b2ba85a368e366ae3f8ba662b6c71279782c40fb8161f2d06749ce9424948734cd97a45f581eb3d714f64baa4dac788fc08aeaa9cebc536fd17126370f96fd3eb40bbb1358f58c3954950de35f5f65ef64f5c545f67915501ebb9d1e0b3f981963004ccc3eff13ca3d7689825a3a4591efb285fcd148e5a60e19bc32f7d4dd67891ca4c83dcc6a69084ee22b3eff9a04195127d5c60f2675a04b1d68a118a7eb4c669856464d7335611efdb6c38875296e1d3bd0094cad3e0228872aab53244e810bc200d16d4f3dedcffa6c4e7a70837387d6dd755a8051573e13cec6b73fb907556ddb90285de444553472825e48b5670902e8787bffb9f439373658ced8500cf817e6c488825f4e6b33009886f5377c7facdef9eb7329842358222d82c15c18a30a0f549b603e1c4f6fc456f1a3afffc0dcc36f8eeb2fbcd171268a22a0a79196f670ebdb74e6161514829aaacec219f84e7408e6b373c64f53354d6580a71d99d76a9e15bd648cbb2476693671299f36a96e89dd073c60a15e573d605a747a542d9f97ab6d8f2de3638358350bf039f5e531d38eb57d731a8305dea693c27511a639c7e48b56e20c559d211ddde37960c6b4ace95707aa42594451e63e1107dfd824037e075cb17091cf803fa7b7be86bf67ef70cedb7bee4434460e498f8063afcc3d2b40a1c3891c08b4341925c82d6404073fd43a805331e7390235cc1e0116551e2ce8936c446dd1cf8aff1dd6d02cd31e3a266625176eb596452ce1016a710c3b7b62f33d549e221b63f034668a73e5fa0f3f1255e7bf4016dcf0fb4f194dcd37db59b806cdbc17b244c32eca6527dc2bb9e9cf833790d40b209a862097ab650d054619e45e97c93192cc515e9964e0a0421273a1d35b0ba7b82a617cf125d43107ab24ccb7b131577c95e68bad1f1862a7d5b8e797925b3b04b630b589b6e80780a26fee9830ce0fec4d56483c51520e19f3c98ab4b1e31e2fd8632bd22b80ff98a9a60eb610e576add85381212094849aaca16c45ca12ab93a4b45e58606b0902a6d25167d7eaebcc186986407153d87bdfbb6a082298dadae7fd96615a084e3e34a0e40396c02fbe9612664e5f6700571d3dbe49bf2d334c774999e8638b3fa9d3c6321838d0d593bb1c6e1cbfe0a212d18ee01d0c1b15c6ee5282d2f7cee54b7472545a7d22d4775315e30b03da83962b295054139387eecbabf67f22c1d113ed67104578e73ec17e9aa650a55a1cdecb125b981e4ff69a54481d9ac5e4d8e396dfd39218b40df2b175e6059e6d7cc33287e1dd36c3dabcf74e78eeba3f6246508910f73c18b056856c31b737ec89ad43cb10fe1f591a4fb6f2a0c67c703a28a71a90fb9779e3ebff4c473d81c6455b21724e622611366bd1719433599dd1d8a3674630c0da6d291dfb2a75eaa177b886101ec207aa13ce7bc904b9a3af3c1b1479f2fad7c53e0e18c8a42c0f87ec3ee41877cc71047d80ce2f3d1cdaad6fab7bc6810477977ac77b67c6e0814d45b162e1ae0b623","isRememberEnabled":true,"rememberDurationInDays":"2","salt":"60e479884f18cc4d2836fdf1b8b9fcda"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
