<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Locked Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: template_color_primary;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: template_color_primary;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: template_color_secondary;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Locked Page</p>
                <p><p>enter the passsword to unlock the page, don&#39;t try to guess it, you&#39;ll just waste your time.</p>
</p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="Unlock"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = 
    ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassphrase) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassphrase
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassphrase) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassphrase(passphrase, salt) {
    // we hash the passphrase in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassphrase = await hashLegacyRound(passphrase, salt);

    hashedPassphrase = await hashSecondRound(hashedPassphrase, salt);

    return hashThirdRound(hashedPassphrase, salt);
}
exports.hashPassphrase = hashPassphrase;

/**
 * This hashes the passphrase with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(passphrase, salt) {
    return pbkdf2(passphrase, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassphrase
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassphrase, salt) {
    return pbkdf2(hashedPassphrase, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the passphrase so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} passphrase
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(passphrase, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(passphrase),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassphrase, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassphrase),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassphrase = await cryptoEngine.hashPassphrase(password, salt);


    const encrypted = await cryptoEngine.encrypt(msg, hashedPassphrase);
    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassphrase, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassphrase
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassphrase
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassphrase,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassphrase = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassphrase, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassphrase = originalPassphrase || hashedPassphrase;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassphrase = await cryptoEngine.hashThirdRound(originalPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassphrase = await cryptoEngine.hashSecondRound(originalPassphrase, salt);
        updatedHashedPassphrase = await cryptoEngine.hashThirdRound(updatedHashedPassphrase, salt);

        return decode(signedMsg, updatedHashedPassphrase, salt, backwardCompatibleAttempt + 1, originalPassphrase);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassphrase),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassphrase
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassphrase) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassphrase, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassphrase(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassphrase = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassphrase) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassphrase);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPassphraseQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPassphraseFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassphrase = hashedPassphraseFragment || hashedPassphraseQuery;

        if (hashedPassphrase) {
            return decryptAndReplaceHtml(hashedPassphrase);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())

    const templateError = 'template_error',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"fbe1bf51f55e1e79e6403f7a84003829af592aa002f6374e15e403be1a221374145e33b3e607d5924c3a31d9e5cc77c8bbefa165280e96464f54158c5960c5297ab8e8762410f86774c15a8d8403f9c1613067294ea6df40f55149dc494c9dde92abe44058faae786dd2465da28a604f982c92fd22f1f1750e5ce0b3ecdf456144970bb3db8bfe9216085a48ea605fbe11168576d004b1711ba0068b3bf9456a037dbe160444e1a923d79d0bfeaf05048ff91db57c4bb2fd196883b8777cf9a491f7d48c6bc9d57131ca1db28471a35d09ec02d08efff867f1a1105009577e4b4ad9881f3ed32cc4fc4794da263b4cfb0f4848bab6c5a1f9a07c1aaa0c14a4cfb5dfd438088717f0a710bae7e506cc712ecf05e4eaffc030097b08a65f9e2a30b308b7f0a992f13cb9e7f9321648b62cddafc52c6afbd8770cb6f549e24f966670c4c9ba0d2f62fa90aac0970758f1f9d40f6a5047c70e10f3800e874021d949445431ad046b1ed5e89e522f2f645318ae794efaacb98c9551434d91f1a9461bb9032926247265922b3489e207f82676855ba47dd873f4735271af0f710a5f86a727a0559723f368043a39b6b5286ccb1354238d6e3cf412a02f82f4424da925502514f484c5b8d137c8afc8f09ed9edf5ad6b902248afe29ab819319c39fe80ecff42f2c304e42dfa8bf17065971a08f67250fb85f328f48098e6bfefe5c16f1894eb79875314cacd14571bd614d146ebc51bd6fe8d58eb4df8bb50bf205a4e6433f48f284f75791b21204527e4ab5327631fc83e49713e3ff66a24102b255e07b4618350ffc0a84592e1b489f84153b3163b070857f6b4347480e61f1a7792f21de5ba662d339922a182b609f9b8d5a1e62d0c593016b74be7d7dd2b5d168edcafb333913991ba3e4c79b959fd888eb0e422d264914d16b035ff3099d12b3a72d3172a6a000f0f65adc6b407ba62742ead403b66136999468433909b0b246af68c699daa8ad8e1e7c40544f2766e5293da6af57bd58e1c71958dfd000c017b7aa11094647335f8e1cd9e8110e5f3ee301da4fc0b7dcbb7c1a4ad245acb42da520c49c9970faf9b784fa04c61e8790e0f44cb9284a4ecc4c6f5460f3e18ad55f1227d6444a5586614ca59a8809c059d479cc8dd66b30e72a843286f3abf3e92ada8242dfc7d3eb1fc46a7acc68cae40155408f21e28740c1a79345ee55ccfac3b9f118874f047b59876bd17cc93fcd5ecc9dcced23ea64586b99661b2cbe17a8dba4da2fe56c28c0c48f87e3c36172c3412d97dcdff4cfafd4da93fe44013c5674f0c56ed6b7bd088db080382b87a0f7e14236d989b026ce8f37e9182d93451f27fc14083c1e27d0b32c8f66aff5c35cdc7f3781bae91e8af2b8068aedf88308f1c0b71fa9908cdb76c2d35de47ca13bb3b098a4bf51c9c786557b371a0e0f0ff7973d3010bf1192503d36dc6a8359200c47e58880e30399209948e11b64acda22f2e94cace71e0dea6e61d229c37cbcb7fd9fcab0c655083ad699c8ddad3b781ae83ac21f805934fef4e3399d731cbc05688aa3330ea759650fce3c55dd910a89a8a12148693e418444fa67a297e1eca9fa64eb859ce56d6802c08d16ddecfa58fec2d120900ca35ccb5034d43ffa8666b27494a77476253b293dae2488e8b273591f0b6468dbec7ba5cd26babc2e13eb3ec3a52b0762948f47abb356df48c3c537ad315fe313620e388334c0f056e670909d16cd83e453e9ef7110f54554bde6b1338e47a82de7d587be79c9ad8e7bfc5acf98608cc0697a628a89f468c59b1c3c818f630440a282df4e26f0929641aed19746eda2fa00d9f99cfc529f5ba9222ab2905e97a6b93d674afe66315df4bd636c1a2a211ed59d4095ee04e5e88e83961376cb2a7b1c4cbc2d35e9da581e905eab257b4835fd1f183d599d91ecfca30f6e24ddc9719fd39c5c3b91cbc76ab1d3a8d54661c555696f6eb9928be074bd915393213e76e1ed649787d7b8cb24be6ebe92e93c610ec3ae83fa674ec92a2c403980a6c5d6cde73a6617f37741d0148544b1e43e076383becdb04215af4bb0787494bbca04fc00f744a441c4104b2b64b8a0b52235ff44660f60d45d73c1dfdcdb1800427c0e0ff9fd893721e8bec682f9a0e865cc36e3dc32abfe58b5bfffcf67e4bbdf0bd8cd404c8b4c27f0777eded53933f114a4cdeab25bdfa915f1973498539c554f7f54fdaa86986a77feef0b45daeae3e56ae6790d75744bc4a7707a9cd12f720f70cd20794a43912ef76ca084b8bfe4917ae8be11b634de39e97b30c92c02349f18d7a3b025ef1cc4321c94865a1976e60beca337dbdf29dbc0d8923ff710e57ab0fd1357d14e317646f70e5638407a898dfc983b0927ecbd40404628ac85196d3b043231149774215dbef2167671211f183c3b11668932fe1f781be274f4e6c5d61df80d103bde14b263500fcdd16f1636e84b18ed83c148c33943742ff89d867f290ec30e693f4c26f6f97aa95a2926f70026c187e36d1865f8df795031026680f9d1b2ea8a82d6acbcfdbba16eceb8f67db0505c0d3d3ef32cf83bc111a279c1db9eac594f7c037e1781263e1e9dd364a60c26f70fcdfeaa6cbbf99b9ed8b4c56fcf76bbbb91ebcf2ec12f09d326fefd15c22dd19027338bb4112521217a1c81044677985a272c1744d3a1d2114fb1b7502e320414c6aeef50c400fbc9ee1fe94cbe69349b5c7165a345ec1a65ea243899613a81369d6e88ac9d5ae313816ebe83a53ad0e3d4c686a177878e8b6b116cfbfc5eb8456333b789f97fbc60421bd9a7e34346737435720f8435d1266e9168b268d87fcbbdc63a51cb9fc7e6e239195d7d6efb3a4cb01038eb65edf5192f81e03c43679f62764e4ab2bd04a3539f1ccc69e5e3ea61695420df0f5e2cf771f06396d5a7c6bf54b3f55e5d6bfc770643203e412bb7484617066519ea0ca417b7283baeaab8dd1c3543f5845d3749ab8e4134edd0bcc9fc464d6049592695c60ee25ace712c392e35b2de1b0e162c84faadab4630cf2cf215f3cc669466b84f0d23995e164ed617ca8b45ffe430bc46bddbe4af5f9c27da55d4cb5345f4815e3ac31a0a03b99f1ae7d4855770bd3a0b1d5f6b8f1395accc44f3ffb4b269147119acbc27a1119e684293c8c4b4d60467d147a8dd764e737673d485c36d9ab3f1dc8425c7223e81268125cef9d13a07d4bab921fd03cecf9eaa4f2f9a466306ace1385b9c14b4f397995b731a03042aeee465e12cd4908f387f5f4ef039f0a9a1be9ceae4f3303d37c15a37b77f8119d055c73c0feafece31a781e1af276beca73900c0d97cb6bde231e19cfddf62404d0edd927abb0d2782e00aa1aae63ff7aef281c5a583009a8e7d56cf661b206b098be740669c6642381d97cb12116622ebf8751a6dfaee4e19f701d16aaf24b91e8d063f83d32dff2f5bf39b0582e3a3ca7769eab71f09dcdf927ee73189cb97db5c1f04d50aac43ec024be201df3a74a9072360ea69f1caf3870aebd2a8e725d8b411b41a7d15371121d8127eab973e0b1116249f510184cd0af4b6bf9be22cdf303ed92d91bfc9118362f45204fec6a93a5bbce066cf5037f80464dc4783f368b87a8a94b2ce41ae9f08977f70e0c1538523e1db7f084ca0e9dbfbb212d01c612a6486bf1870c72e8807b2ffa66fe81fe818a9aa1e32b70e83837de2394d5ee313ebc699541a925515eefe44dd94ddc05588294b7c69f6534bbbe7db024eae7e1a41327d7185e2c25aab4b44a537d04d758805ce7d45f42a286bd3ee7def44939128a4afced44e8e8782e2c7cad12a0e9bc93a1efef77c1e3cbe476fb08c428b3eb1f323ec7eef456334844ac18c1135475f1a92d04a7bde4063db37fd205b32f2bba943cbf3becf52308594d581a2a2bf5203bbb0248f17f48ef13fdb649f280437454f1cae56a8833dba09f9072773e50c2f674c7142e4abc3f9af9238eee60eb1f30f3fd1359c672cd4db4dd9bac5f9189ae1f70301ad02f1598690245587343462f8a576b7e9af8f9edca1e608f9d4a3892c91a17b9302060629f093fee253921739b0ce7e6721cd7e6cdad9daf2514beac777911fdf71ea93233b0c5716ce414e6f0e8b296be3e2475d769ccae603f6ae89d9fc75304524659b214dffdefd4bfc53d7f8c00ab4928a7844f212a3311e2627aca7ab255a7dce3619802c6b0f81c0096de6fb50f5c9ee4172849410d280fa10d0ea29ccd34d5588e717fc2f6a4493cc3196832085660a9e2f72c4dd944706b7bde33e15b931cf11caf47bd826896414af1af6386e0d87c1f965263f2a2ba11d26c00031330b3244d873b15b02bd8eb7181b34a79103ff852196d7a80b7d393c700b68fcc530d5666068437ad6d3cb5cdb7f70e54e2e9d996ae0accf4b0b73192ade04af622c9a87c5e2d50549a31efcde496c901a375fcf961e349005dd4840c1a76e81ecb1089f10821bae8fba4d119d6b349dcdb0e47bd94236c94b14bb977f57bf615ae1b0d53a24793a3b356342068b771dd1bc789ae1f21d9fe0ca0a3b3858971c88d046ae74d1d85d4e1f234fae178a1ebb548894ab52e714e48563dc81cb60d6c92a41b0b2cb623b6c3bbcd0c977c703283e560119a6a79b383819f77a23c9ec5749fad9c6c88817ee9918f2af6456647db282ddfd6fdc8daf8fb71f893eb7d5c7f6579797736140067ee42a8ee9b064f0b9acff3f1ce2244520df7376adcd2ad1a9746eb9a999e560b1cdf701a559d77fb250fbdb258fe9b0eeeec42dafceb6747b6857bbe3858c6b44d95b6cbc9acb9e9aac334e61f3f89c1a9120f0c18dd582ddd29665145416bb605fcbdf57c02a962d01f86cccffd1288c3bdfaf581b75b621555f68c6095d81eddf9723ec939952e24a79d21e4ef545ca3932afc71e760b163645d883bda023ee569ef03bf1d316085b2b24dc3b457bbb9387993191c25d2739b39368dd45cb5ccf6c052ecd433cbdcc74ed04f427f656dae1c407843de2adefc2f227fd247c57656311521266fccc01cc2a0098ee674836a6063ff70fbf6707021ae3e9fbc1ead4db60dc72140b04d1ae91e6b574f450e531f433be62b60276f5e4f60b6f97b2ec25855b6bc499be21e9f6f550d2d068cc762d939ce3ead126582c3a726d9781c5371f92abe9ee9b8dd2970461ff60c8f3c9975981f3bc53df5dad015561738d44994ca0c3f0bc7c31d793d237bb1f98162b3991f972af6ebe8b2cc4f751aa88a098362f8ea22c40be960d5015641728894b34c693bd9a105fa1384b1d54bb16c21bd82aa9c4c755128317b7fc10c24c59778bc06e91d3a834b74760dd0b79ed1ac4a9b5d09a828604dd31ba6712365607106bb1fe6a9ab1bbfa6e1b32b4a01b030a9b347d4cea182c1762d666b2cef766c9bcc1c747d62a645c75c99470d6af1be058226810d67e6c3ad344209855e26a61bbea67268fd0763c6d5369f2659c7e2ce465392599e69debfc59affa930d51d8831c561ca42d3172bed5bdbf109086a8c3e3b1482e4b30ef8f41aef476e562fe7ec04d7e11a9f0f5b88bb000f7ee8c9a52fb60ce4d4e3ac653a72113e7ed02a0a774997c8d27ffb5d79ec5fbe79b98b4208e83f39de2b08cbf7344a5bb8976c4a855918067c9ef46d2659cc3bbaeaa5d0c699d9c803bf4a0a5624f690e62a8b2c8db73928be8fdca85f5c2f3413f74c421fa66afa4b6e0d31b2df59fad20bb24691eae76c64aa405b5423b1f880f5ffa91897e2045d5456adc20a0d5c27b30c003fa74ca5e4e75a92f1e0fb51a51b30cf64f09747a570a4059795ff388ce42dce604507d56f8ccd047857d26432d3a08510168ce1ad6cbf371eed0ecd34daae41e4800d262c7b4c09ec6745acc0d29ecb904bd4fc09444d0593feb1e046e375339b2b80b36b2a18755fddb202e399d8b22eff045a40fee663d1fb85fb553e5882bb7ecaa06c3717b606d1edca99a76a582455022cbfce591d20fb67b0886c3617532e740c6faed6d8a1f153d92b748d364e06e51c2ce14d7b204c3415b53ac3af73401f9911a9157ca3924060e4145efb9a30f45c10269bafcb84b87fbe05ad8772a88d6b2efba902241343307cb7c233e1e02f4e01f8249abdb53f51e1b42a219e770ec89ab99a1b7a6d746871d5cbec5efe3b92f34dd469c447a948a0bd313bdb97616ce7eb869e9d2e53df547f4d0bc2ca3a72ab30c38968143089f383860f39b95bd8bc6eeb1aa88d19af8f6654a085ecf320d27b610c7d1ee2ce8f171276bcd85ad8e56c01ef8d5388bd4c36cf9e1f0fb9022df25a2df4f6b4d5b4182ab89dea931524b0316921207b272dbea636b2d9abdce149e41441c35d0ba9388058b94b7af4dd28b59332436c5451f968a603d97d7cf714924457018255b0fd58c61de011783c0d79b563a14aef4ba66f8f0a92ead3fd38ab66a850961cf2ee74d9457f6ad59ddf45bca52a9c681093dc2e9c7f76f70281b7548273812b281e357391c819b7410ea90d4909e6c139d647ce5ff72f59903259e6bc8cf23758be9c8b3cfef142cd695c48505e4fd50120d6603459000bd22c8b2c01434fa2c1a9f8989d1492010f56be2592a973d905000f1daa3879b6d5ad484e51640373d9f177888bdb055c681b0a39a31a64425bdf7c89ae4e33463bc2611f55ecf876f10a9615b9697d78c9d8a8b99106419dce652ba0385d6bf80e3238c9585b210823b909d72bd7305d21cfcc54ca482c68c6d440cc12ef5be1b5640379f04f6befc6dbdce6b379efa61afeac3ebb2752f622ad81018e714d7be3a25b2fa82872389d98d503d7d4ace9862598fcf9a40d7e2354ca7e056d720e98b50863d75b5fe95a9dac1129cf3f42e8f30616fa1f860a9b4944ec53a2d88ed73133988f24cba7bab875a9b0fdb47dbd5cd1560b41a5fb0c1ea7ea13934ddf05c7dfdff2b2b668b9a0ce94010630ca929f1ba4bb1af71bc88041ff3855da76c1d285b6ae2530f0e3c132d63f557662b08ab80d6ed19af169a8da692920b2a11fd71b7dad626bc8fabc0d346d11eeb1d5cec4d00699177697146507f28b74d99c8e206436a232eaf7e320b0191856e23ab9f393094af507462cd25fae0369d2c7065131dddc484f3aa7983393f1253d4a02ebdb7efcd9af53192189092d4daa37e40e1c2d83a38c00432719b1196e33614a68431b5e6184d3e91f20669b5eea98592fa3cee642ee2ab676b687c50582249e62721ce02bf6853731d0476b21513394ee40def3d1dfe71d6fd398dfffe9fe3375a22be61e93637260b2515a17c06b089b012f52e1aa6e3dcb8e6302256ec368adf91e781485d7e871522d14fea817d0f276d2b340703391971337b8468acf94f279da37bb7b112c4ecf298625232eed76939985fab7dc7f4535dd4709d714db92565b3482db6f62ae869d6eda2b0484b332e64a98ffea5c847a651070017041dc13b8c8753ac615c556e6b3c40e888a7d51efffca3000af90aaacc1d03a36d5d835856c2abf1f4e1499c991f8f7e497e68e051d1cc5038f5c9f4040a2ba38adf3413af254410fffd473521bf1745cc0a041a42f3bfe5419670fe36fa84028e4a37d393a009d29bd1527d4345e9280a77f6bdf1956fb05140d034af425ae5cf90f9c9c273632d7d3e81b841a977f8cd80616d97e0910ac92e0f3afe89e377da45395547a25183360cba60f3ba589bfe4279fdc8fd05bb4eabf63f030ceb073d9e8a33910e99317a85c29416552d12234c1be693401d8316ca92d3dec85867a330be274b5751fac9d8024898143c017ce320b7740edcfc2747914cdad4022cd977776a49b1dfbe176af6742bea795","isRememberEnabled":true,"rememberDurationInDays":"2","salt":"8a48c8c655cf5c46df3e9d69dd23f777"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const passphrase = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(passphrase, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
